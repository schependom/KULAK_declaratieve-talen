Bewijs dat de lijst monad aan de tweede monad wet voldoet.

## Definities

```hs
instance Functor [] where
  fmap :: (a -> b) -> ([a] -> [b])
  fmap f l = map f l

-- met
map :: (a -> b) -> ([a] -> [b])
map f [] = []
map f (x:xs) = f x : map f xs

instance Monad+ [] where
  unit x = [x]
  join xss = concat xss
  -- join [[1, 2], [3], [ ], [4, 5, 6]] = [1,2,3,4,5,6]

-- met 
concat :: [[a]] -> [a]
concat [] = []
concat (xs:xss) = xs ++ concat xss
-- en 
(++) :: [a] -> [a] -> [a]
(++) [] l = l
(++) (x:xs) l = x : (xs ++ l)
```

## Effectieve bewijs:

### Basisgeval: `l=[]`

```hs
(join . (fmap unit)) []
  == -- definitie (.)
join (fmap unit [])
  == -- definitie fmap en join
concat (map unit [])
  == -- basisgeval map
concat ([])
  == -- basisgeval concat
[]
  == -- definitie id
id []
```

### Recursief geval: `l=(x:xs)`

Inductiehypothese: `(join . (fmap unit)) xs = id xs`

```hs
(join . (fmap unit)) (x:xs)
  == -- definitie (.)
join (fmap unit (x:xs))
  == -- definitie fmap en join
concat (map unit (x:xs))
  == -- definitie map
concat (unit x : map unit xs)
  == -- definitie unit
concat ([x] : map unit xs)
  == -- definitie concat
[x] ++ concat (map unit xs)
  == -- inductiehypothese
[x] ++ id xs
  == -- definitie id
[x] ++ xs
  == -- definitie ++
x : ([] ++ xs)
  == -- basisgeval ++
x : xs
  == -- definitie id
id (x:xs)
```